# analysis tools

import os
from typing import Optional, Union
import time
import json
import urllib.request
import math

import sklearn.preprocessing
from torch import Tensor
from numpy import ndarray
from tqdm import tqdm
import pandas as pd
from rdkit import Chem
from dgllife.utils.analysis import analyze_mols
import matplotlib.pyplot as plt
import numpy as np
import seaborn as sns


__all__ = [
    'loss_plot',
    'parity_plot',
    'pca_2d_plot',
    'residual_plot'
]


def loss_plot(losses, model_names, fig_size: tuple = (10,5),
                              save_fig: bool = False, path_to_export: str = None) -> sns.lineplot:
    """Creates a line plot of different losses on the same scale.

    Parameters
    ----------
    losses: list
        A list containing the losses.
    model_names: list
        List of the dataset names or loss type.
    fig_size: tuple
        The output figure size. Default: (10,10)
    save_fig: bool
        Decides if the plot is saved, is overridden if a path is given. Default: False
    path_to_export: str
        File location to save. Default: None

    Returns
    -------
    sns.lineplot

    """

    if save_fig and (path_to_export is None):

        path_to_export = os.getcwd() + '/analysis_results'

        if not os.path.exists(path_to_export):
            os.mkdir(path_to_export)

    loss_dic = dict()
    for idx, name in enumerate(model_names):
        loss_dic[name] = losses[idx]

    df = pd.DataFrame(loss_dic)

    fig, ax = plt.subplots(figsize=fig_size)
    sns.lineplot(data=df)
    ax.set_xlabel('Epochs')
    ax.set_ylabel('Loss')

    if path_to_export is not None:
        fig.savefig(fname=f'{path_to_export}/loss_plot.svg', format='svg')

    return

def parity_plot(prediction: Union[Tensor, ndarray], target:  Union[Tensor, ndarray], fig_size: tuple = (10,5),
                                        save_fig: bool = False, path_to_export: str = None) -> plt.axes:
    """Generates a parity plot based on the given predictions and targets.

    Parameters
    -----------
    prediction: Tensor or ndarray
        A prediction array or tensor generated by some sort of model.
    target: Tensor or ndarray
        The target array or tensor corresponding to the prediction.
    fig_size: tuple
        The output figure size. Default: (10,10)
    save_fig: bool
        Decides if the plot is saved, is overridden if a path is given. Default: False
    path_to_export: str
        File location to save. Default: None

    Returns
    -------
    plt.axes

    """

    assert len(prediction) == len(target), 'Predictions and targets are not the same size.'

    if save_fig and (path_to_export is None):

        path_to_export = os.getcwd() + '/analysis_results'

        if not os.path.exists(path_to_export):
            os.mkdir(path_to_export)

    if isinstance(prediction, Tensor):
        prediction = prediction.cpu().detach().numpy()
    if isinstance(target, Tensor):
        target = target.cpu().detach().numpy()

    fig, ax = plt.subplots(1,1,figsize=fig_size)
    ax.scatter(target, prediction, linewidth = 1.)
    ax.axline((0,0), slope=1, color='black')
    ax.set_title('Parity plot')
    ax.set_xlabel('Ground truth')
    ax.set_ylabel('Prediction')

    if path_to_export is not None:
        fig.savefig(fname=f'{path_to_export}/parity_plot.svg', format='svg')

    return ax


def pca_2d_plot(latents: Union[Tensor, ndarray], labels: Union[list[str], list[int]] = None, fig_size: tuple = (10, 5),
                unique_labels: list[str] = None, save_fig: bool = False, path_to_export: str = None,
                log: bool = True) -> plt.axes:
    """A function that projects latents or any other matrix onto it's first two principal components and plots it. Can
    use given labels to colorcode the projections.

    Parameters
    ----------
    latents: Tensor or ndarray
        Latents or any other matrix that will be used for a PCA model and projected on the two first principal
        components. The first dimension should be the observations and the second the features.
    labels: list[str] or list[int]
        Optional list of labels that will be used for the plot. Default: None
    unique_labels: list[str]
        Optional list of unique labels that will be used as a legend.
    fig_size: tuple
        The output figure size. Default: (10,10)
    save_fig: bool
        Decides if the plot is saved, is overridden if a path is given. Default: False
    path_to_export: str
        File location to save. Default: None
    log: bool
        Decides if additional PCA output like the explained variance should be printed out. Default: True

    Returns
    -------
    plt.axes

    """

    if isinstance(latents, Tensor):
        latents = latents.cpu().detach().numpy()
    #if isinstance(latents, list):
    #    latents = np.array(latents)

    if labels is not None:
        assert latents.shape[0] == len(labels), 'The given label list must match the latents.'

    if save_fig and (path_to_export is None):

        path_to_export = os.getcwd() + '/analysis_results'

        if not os.path.exists(path_to_export):
            os.mkdir(path_to_export)

    model_pca = sklearn.decomposition.PCA(n_components=2)
    model_pca.fit(latents)

    V = model_pca.components_.T
    projection = latents @ V

    num_labels = None

    if labels is not None and isinstance(labels[0], str):
        enc = sklearn.preprocessing.LabelEncoder()
        num_labels = enc.fit_transform(labels)

    fig, ax = plt.subplots(figsize=fig_size)

    if num_labels is not None and unique_labels is not None:
        ax.scatter(projection[:, 0], projection[:, 1], c=num_labels, label=unique_labels)
        ax.legend()
    elif labels is not None and unique_labels is not None and num_labels is None:
        ax.scatter(projection[:, 0], projection[:, 1], c=num_labels, label=unique_labels)
        ax.legend()
    elif labels is not None:
        ax.scatter(projection[:, 0], projection[:, 1], c=labels)
    else:
        ax.scatter(projection[:, 0], projection[:, 1])

    if path_to_export is not None:
        fig.savefig(fname=f'{path_to_export}/latent_plot.svg', format='svg')

    # TODO: fix the legend being way to big.

    return ax


def residual_plot(prediction: Union[Tensor, ndarray], target: Union[Tensor, ndarray], fig_size: tuple = (10,5),
                                        save_fig: bool = False, path_to_export: str = None) -> plt.axes:
    """Generates a parity plot based on the given predictions and targets.

    Parameters
    -----------
    prediction: Tensor or ndarray
        A prediction array or tensor generated by some sort of model.
    target: Tensor or ndarray
        The target array or tensor corresponding to the prediction.
    fig_size: tuple
        The output figure size. Default: (10,10)
    save_fig: bool
        Decides if the plot is saved, is overridden if a path is given. Default: False
    path_to_export: str
        File location to save. Default: None

    Returns
    -------
    plt.axes

    """

    assert len(prediction) == len(target), 'Predictions and targets are not the same size.'

    if save_fig and (path_to_export is None):

        path_to_export = os.getcwd() + '/analysis_results'

        if not os.path.exists(path_to_export):
            os.mkdir(path_to_export)

    if isinstance(prediction, Tensor):
        prediction = prediction.cpu().detach().numpy()
    if isinstance(target, Tensor):
        target = target.cpu().detach().numpy()

    residual = prediction-target

    fig, ax = plt.subplots(1,1,figsize=fig_size)
    ax.scatter(target, residual, linewidth = 1.)
    ax.axline((0,0), slope=0, color='black')
    ax.set_title('Residual plot')
    ax.set_xlabel('Ground truth')
    ax.set_ylabel('Residual')

    if path_to_export is not None:
        fig.savefig(fname=f'{path_to_export}/residual_plot.svg', format='svg')

    return ax