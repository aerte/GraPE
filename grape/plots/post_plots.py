# analysis tools

import os
from typing import Optional, Union
import time
import json
import urllib.request
import math

import sklearn.preprocessing
from torch import Tensor
from numpy import ndarray
from tqdm import tqdm
import pandas as pd
from rdkit import Chem
from dgllife.utils.analysis import analyze_mols
import matplotlib.pyplot as plt
import numpy as np
import seaborn as sns


__all__ = [
    'loss_plot',
    'parity_plot',
    'pca_2d_plot',
    'residual_plot',
    'williams_plot'
]


def loss_plot(losses, model_names, fig_size: tuple = (10,5),
                              save_fig: bool = False, path_to_export: str = None) -> sns.lineplot:
    """Creates a line plot of different losses on the same scale.

    Parameters
    ----------
    losses: list
        A list containing the losses.
    model_names: list
        List of the dataset names or loss type.
    fig_size: tuple
        The output figure size. Default: (10,10)
    save_fig: bool
        Decides if the plot is saved, is overridden if a path is given. Default: False
    path_to_export: str
        File location to save. Default: None

    Returns
    -------
    sns.lineplot

    """

    if save_fig and (path_to_export is None):

        path_to_export = os.getcwd() + '/analysis_results'

        if not os.path.exists(path_to_export):
            os.mkdir(path_to_export)

    loss_dic = dict()
    for idx, name in enumerate(model_names):
        loss_dic[name] = losses[idx]

    df = pd.DataFrame(loss_dic)

    fig, ax = plt.subplots(figsize=fig_size)
    sns.lineplot(data=df)
    ax.set_xlabel('Epochs')
    ax.set_ylabel('Loss')

    if path_to_export is not None:
        fig.savefig(fname=f'{path_to_export}/loss_plot.svg', format='svg')

    return

def parity_plot(prediction: Union[Tensor, ndarray], target:  Union[Tensor, ndarray], mol_weights: ndarray = None,
                fig_size: tuple = (10,5), save_fig: bool = False, path_to_export: str = None) -> plt.axes:
    """Generates a parity plot based on the given predictions and targets.

    Parameters
    -----------
    prediction: Tensor or ndarray
        A prediction array or tensor generated by some sort of model.
    target: Tensor or ndarray
        The target array or tensor corresponding to the prediction.
    mol_weights: ndarray
        Optional, will be used to color code the residuals based on their molecular weights given.
    fig_size: tuple
        The output figure size. Default: (10,10)
    save_fig: bool
        Decides if the plot is saved, is overridden if a path is given. Default: False
    path_to_export: str
        File location to save. Default: None

    Returns
    -------
    plt.axes

    """

    assert len(prediction) == len(target), 'Predictions and targets are not the same size.'

    if save_fig and (path_to_export is None):

        path_to_export = os.getcwd() + '/analysis_results'

        if not os.path.exists(path_to_export):
            os.mkdir(path_to_export)

    if isinstance(prediction, Tensor):
        prediction = prediction.cpu().detach().numpy()
    if isinstance(target, Tensor):
        target = target.cpu().detach().numpy()

    fig, ax = plt.subplots(1,1,figsize=fig_size)
    if mol_weights is not None:
        p = ax.scatter(target, prediction, linewidth = 0.7, c=mol_weights, cmap='plasma')
        fig.colorbar(p, ax=ax, orientation='vertical', label='Molar Weight')
    else:
        ax.scatter(target, prediction, linewidth=0.7)
    ax.axline((0,0), slope=1, color='black')
    ax.set_title('Parity plot')
    ax.set_xlabel('Ground truth')
    ax.set_ylabel('Prediction')

    if path_to_export is not None:
        fig.savefig(fname=f'{path_to_export}/parity_plot.svg', format='svg')

    return ax


def pca_2d_plot(latents: Union[Tensor, ndarray], labels: Union[list[str]] = None, fig_size: tuple = (20, 6),
                fontsize = 'medium', save_fig: bool = False, path_to_export: str = None,
                log: bool = True) -> plt.axes:
    """A function that projects latents or any other matrix onto it's first two principal components and plots it. Can
    use given labels to colorcode the projections.

    Parameters
    ----------
    latents: Tensor or ndarray
        Latents or any other matrix that will be used for a PCA model and projected on the two first principal
        components. The first dimension should be the observations and the second the features.
    labels: list[str]
        Optional list of labels that will be used for the plot. *Has to be equal to the latent length.* Default: None
    fontsize: str
        Decides the fontsize of the legend. Default: 'medium'
    fig_size: tuple
        The output figure size. Default: (20,6)
    save_fig: bool
        Decides if the plot is saved, is overridden if a path is given. Default: False
    path_to_export: str
        File location to save. Default: None
    log: bool
        Decides if additional PCA output like the explained variance should be printed out. Default: True

    Returns
    -------
    plt.axes

    """

    if isinstance(latents, Tensor):
        latents = latents.cpu().detach().numpy()

    if labels is not None:
        assert latents.shape[0] == len(labels), 'The given label list must match the latents.'

    if save_fig and (path_to_export is None):

        path_to_export = os.getcwd() + '/analysis_results'

        if not os.path.exists(path_to_export):
            os.mkdir(path_to_export)

    model_pca = sklearn.decomposition.PCA(n_components=2)
    model_pca.fit(latents)

    V = model_pca.components_.T
    projection = latents @ V

    fig, ax = plt.subplots(figsize=fig_size)

    if labels is not None:
        for label in np.unique(labels):
            idx = labels == label
            ax.scatter(projection[idx, 0], projection[idx, 1], label=label)
        ax.legend(fontsize=fontsize)
    else:
        ax.scatter(projection[:, 0], projection[:, 1])
    ax.set_title('PCA using the two first PC\'s')

    if path_to_export is not None:
        fig.savefig(fname=f'{path_to_export}/latent_plot.svg', format='svg')

    return ax


def residual_plot(prediction: Union[Tensor, ndarray], target: Union[Tensor, ndarray], fig_size: tuple = (10,5),
                                        save_fig: bool = False, path_to_export: str = None) -> plt.axes:
    """Generates a parity plot based on the given predictions and targets.

    Parameters
    -----------
    prediction: Tensor or ndarray
        A prediction array or tensor generated by some sort of model.
    target: Tensor or ndarray
        The target array or tensor corresponding to the prediction.
    fig_size: tuple
        The output figure size. Default: (10,10)
    save_fig: bool
        Decides if the plot is saved, is overridden if a path is given. Default: False
    path_to_export: str
        File location to save. Default: None

    Returns
    -------
    plt.axes

    """

    assert len(prediction) == len(target), 'Predictions and targets are not the same size.'

    if save_fig and (path_to_export is None):

        path_to_export = os.getcwd() + '/analysis_results'

        if not os.path.exists(path_to_export):
            os.mkdir(path_to_export)

    if isinstance(prediction, Tensor):
        prediction = prediction.cpu().detach().numpy()
    if isinstance(target, Tensor):
        target = target.cpu().detach().numpy()

    residual = prediction-target

    fig, ax = plt.subplots(1,1,figsize=fig_size)
    ax.scatter(target, residual, linewidth = 0.7)
    ax.axline((0,0), slope=0, color='black')
    ax.set_title('Residual plot')
    ax.set_xlabel('Ground truth')
    ax.set_ylabel('Residual')

    if path_to_export is not None:
        fig.savefig(fname=f'{path_to_export}/residual_plot.svg', format='svg')

    return ax

def williams_plot(prediction: Union[Tensor, ndarray], target: Union[Tensor, ndarray], n_features: int,
                  fig_size: tuple = (10,5), save_fig: bool = False, path_to_export: str = None) -> plt.axes:
    """Generates a williams plot based on the given predictions and targets. The plot is based on the formula:
    X/(X X')X', where the X matrix are the targets.
    This plot is used to expose observations
    that are far from the mean of the residuals, thus exerting a lot of influence on the parameter training.

    Parameters
    -----------
    prediction: Tensor or ndarray
        A prediction array or tensor generated by some sort of model.
    target: Tensor or ndarray
        The target array or tensor corresponding to the prediction.
    n_features: int
        The number of features used in modeling.
    fig_size: tuple
        The output figure size. Default: (10,10)
    save_fig: bool
        Decides if the plot is saved, is overridden if a path is given. Default: False
    path_to_export: str
        File location to save. Default: None

    Returns
    -------
    plt.axes

    """

    assert len(prediction) == len(target), 'Predictions and targets are not the same size.'

    if save_fig and (path_to_export is None):

        path_to_export = os.getcwd() + '/analysis_results'

        if not os.path.exists(path_to_export):
            os.mkdir(path_to_export)

    if isinstance(prediction, Tensor):
        prediction = prediction.cpu().detach().numpy()
    if isinstance(target, Tensor):
        target = target.cpu().detach().numpy()

    residual = target-prediction
    hat = (target@target@target.T@target.T)
    N = len(residual)

    fig, ax = plt.subplots(1,1,figsize=fig_size)
    ax.scatter(hat, residual, linewidth = 0.7)
    ax.axvline(3*n_features/N)
    ax.set_title('Williams plot')
    ax.set_xlabel('Hat values')
    ax.set_ylabel('Residuals')

    if path_to_export is not None:
        fig.savefig(fname=f'{path_to_export}/williams_plot.svg', format='svg')

    return ax